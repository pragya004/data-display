{"ast":null,"code":"/* eslint-disable camelcase */\nimport chart_color_black_500 from \"@patternfly/react-tokens/dist/esm/chart_color_black_500\";\nimport { Helpers } from 'victory-core';\nimport { ChartLegendTooltipStyles } from '../ChartTheme';\nimport { getLegendDimensions } from './chart-legend';\n/**\n * When using a cursor container, the tooltip can be offset from the cursor point. If offsetCursorDimensionX is true,\n * the tooltip will appear to the right the vertical cursor. If offsetCursorDimensionY is true, the tooltip will appear\n * above the vertical cursor.\n */\n\nexport const getCursorTooltipCenterOffset = ({\n  offsetCursorDimensionX = false,\n  offsetCursorDimensionY = false,\n  theme\n}) => {\n  const pointerLength = theme && theme.tooltip ? Helpers.evaluateProp(theme.tooltip.pointerLength) : 10;\n\n  const offsetX = ({\n    center,\n    flyoutWidth,\n    width\n  }) => {\n    const offset = flyoutWidth / 2 + pointerLength;\n    return width > center.x + flyoutWidth + pointerLength ? offset : -offset;\n  };\n\n  const offsetY = ({\n    center,\n    flyoutHeight,\n    width\n  }) => {\n    const offset = flyoutHeight / 2 + pointerLength;\n    return width > center.y + flyoutHeight + pointerLength ? -offset : offset;\n  };\n\n  return {\n    x: offsetCursorDimensionX ? offsetX : 0,\n    y: offsetCursorDimensionY ? offsetY : 0\n  };\n};\n/**\n * When using a cursor container, the tooltip pointer orientation can be adjusted as the cursor approaches the edge of\n * the chart. If horizontal is true, the tooltip pointer will either be 'left' or 'right'. If horizontal is true, the\n * tooltip pointer will either be 'top' or 'bottom'.\n */\n\nexport const getCursorTooltipPoniterOrientation = ({\n  horizontal = true,\n  theme\n}) => {\n  const pointerLength = theme && theme.tooltip ? Helpers.evaluateProp(theme.tooltip.pointerLength) : 10;\n\n  const orientationX = ({\n    center,\n    flyoutWidth,\n    width\n  }) => width > center.x + flyoutWidth + pointerLength ? 'left' : 'right';\n\n  const orientationY = ({\n    center,\n    flyoutHeight,\n    height\n  }) => height > center.y + flyoutHeight + pointerLength ? 'top' : 'bottom';\n\n  return horizontal ? orientationX : orientationY;\n}; // Returns props associated with legend data\n\nexport const getLegendTooltipDataProps = defaultProps => Object.assign({\n  borderPadding: 0,\n  gutter: 0,\n  orientation: 'vertical',\n  padding: 0,\n  rowGutter: 0,\n  style: {\n    labels: {\n      fill: ChartLegendTooltipStyles.label.fill,\n      lineHeight: 0.275,\n      padding: 0\n    },\n    title: {\n      fill: ChartLegendTooltipStyles.label.fill,\n      padding: 0\n    }\n  }\n}, defaultProps); // Returns the legend height and width\n\nexport const getLegendTooltipSize = ({\n  legendData,\n  legendOrientation = 'vertical',\n  legendProps,\n  text = '',\n  theme\n}) => {\n  const textEvaluated = Helpers.evaluateProp(text);\n\n  const _text = Array.isArray(textEvaluated) ? textEvaluated : [textEvaluated]; // Find max char lengths\n\n\n  let maxDataLength = 0;\n  let maxTextLength = 0;\n\n  _text.map((name, index) => {\n    if (name) {\n      if (name.length > maxTextLength) {\n        maxTextLength = name.length;\n      }\n\n      const hasData = legendData && legendData[index] && legendData[index].name;\n\n      if (hasData) {\n        if (legendData[index].name.length > maxDataLength) {\n          maxDataLength = legendData[index].name.length;\n        }\n      }\n    }\n  }); // Set length to ensure minimum spacing between label and value\n\n\n  let maxLength = maxDataLength + maxTextLength;\n\n  if (maxDataLength < 20) {\n    maxLength += 2;\n  } // Get spacing to help align legend labels and text values\n\n\n  const spacer = 'x';\n\n  const getSpacing = (legendLabel, textLabel) => {\n    let spacing = '';\n\n    if (maxLength === 0) {\n      return spacing;\n    }\n\n    const legendLabelChars = legendLabel ? legendLabel.length : 0;\n    const textLabelChars = textLabel ? textLabel.length : 0;\n    const maxChars = legendLabelChars + textLabelChars; // Add spacer\n\n    while (spacing.length < maxLength - maxChars) {\n      spacing += spacer;\n    }\n\n    return spacing;\n  }; // Format all text (similar to below) to help determine overall width.\n  //\n  // {name: \"Cats   no data\"}\n  // {name: \"Dogs         1\"}\n  // {name: \"Birds        4\"}\n  // {name: \"Mice         3\"}\n\n\n  const data = _text.map((label, index) => {\n    const hasData = legendData && legendData[index] && legendData[index].name;\n    const spacing = hasData ? getSpacing(legendData[index].name, label) : '';\n    return {\n      name: `${hasData ? legendData[index].name : ''}${spacing}${label}`\n    };\n  }); // Replace whitespace with spacer char for consistency in width\n\n\n  const formattedData = data.map(val => ({\n    name: val.name.replace(/ /g, spacer)\n  })); // This should include both legend data and text\n\n  const widthDimensions = getLegendDimensions({\n    legendData: formattedData,\n    legendOrientation,\n    legendProps,\n    theme\n  }); // This should only use text. The row gutter changes when displaying all \"no data\" messages\n\n  const heightDimensions = getLegendDimensions({\n    legendData: _text.map(name => ({\n      name\n    })),\n    legendOrientation,\n    legendProps,\n    theme\n  });\n  return {\n    height: heightDimensions.height,\n    width: widthDimensions.width > 0 ? widthDimensions.width : 0\n  };\n}; // Returns visible legend data, while syncing color scale. If textAsLegendData is true, the text prop is used as\n// legend data so y values can be passed individually to the label component\n\nexport const getLegendTooltipVisibleData = ({\n  activePoints,\n  colorScale,\n  legendData,\n  text,\n  textAsLegendData = false,\n  theme\n}) => {\n  const textEvaluated = Helpers.evaluateProp(text);\n\n  const _text = Array.isArray(textEvaluated) ? textEvaluated : [textEvaluated];\n\n  const result = []; // Sync data with interactive legends\n\n  if (legendData) {\n    let index = -1;\n\n    for (let i = 0; i < legendData.length; i++) {\n      const data = legendData[i];\n      const activePoint = activePoints ? activePoints.find(item => item.childName === data.childName) : '';\n\n      if (!activePoint || data.symbol && data.symbol.type === 'eyeSlash' && data.symbol.fill === chart_color_black_500.value) {\n        continue; // Skip hidden data\n      }\n\n      if (index++ < _text.length - 1) {\n        const themeColor = theme && theme.legend && theme.legend.colorScale ? theme.legend.colorScale[i % theme.legend.colorScale.length] : undefined;\n        result.push({\n          name: textAsLegendData ? _text[index] : data.name,\n          symbol: Object.assign({\n            fill: colorScale ? colorScale[i % colorScale.length] : themeColor\n          }, data.symbol)\n        });\n      }\n    }\n  }\n\n  return result;\n}; // Returns visible text for interactive legends\n\nexport const getLegendTooltipVisibleText = ({\n  activePoints,\n  legendData,\n  text\n}) => {\n  const textEvaluated = Helpers.evaluateProp(text);\n\n  const _text = Array.isArray(textEvaluated) ? textEvaluated : [textEvaluated];\n\n  const result = [];\n\n  if (legendData) {\n    let index = -1;\n\n    for (const data of legendData) {\n      const activePoint = activePoints ? activePoints.find(item => item.childName === data.childName) : '';\n\n      if (!activePoint || data.symbol && data.symbol.type === 'eyeSlash' && data.symbol.fill === chart_color_black_500.value) {\n        continue; // Skip hidden data\n      }\n\n      if (index++ < _text.length - 1) {\n        result.push(_text[index]);\n      }\n    }\n  }\n\n  return result;\n};","map":{"version":3,"sources":["../../../../src/components/ChartUtils/chart-tooltip.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* eslint-disable camelcase */\nimport chart_color_black_500 from \"@patternfly/react-tokens/dist/esm/chart_color_black_500\";\nimport { Helpers } from 'victory-core';\nimport { ChartLegendTooltipStyles } from '../ChartTheme';\nimport { getLegendDimensions } from './chart-legend';\n/**\n * When using a cursor container, the tooltip can be offset from the cursor point. If offsetCursorDimensionX is true,\n * the tooltip will appear to the right the vertical cursor. If offsetCursorDimensionY is true, the tooltip will appear\n * above the vertical cursor.\n */\nexport const getCursorTooltipCenterOffset = ({ offsetCursorDimensionX = false, offsetCursorDimensionY = false, theme }) => {\n    const pointerLength = theme && theme.tooltip ? Helpers.evaluateProp(theme.tooltip.pointerLength) : 10;\n    const offsetX = ({ center, flyoutWidth, width }) => {\n        const offset = flyoutWidth / 2 + pointerLength;\n        return width > center.x + flyoutWidth + pointerLength ? offset : -offset;\n    };\n    const offsetY = ({ center, flyoutHeight, width }) => {\n        const offset = flyoutHeight / 2 + pointerLength;\n        return width > center.y + flyoutHeight + pointerLength ? -offset : offset;\n    };\n    return {\n        x: offsetCursorDimensionX ? offsetX : 0,\n        y: offsetCursorDimensionY ? offsetY : 0\n    };\n};\n/**\n * When using a cursor container, the tooltip pointer orientation can be adjusted as the cursor approaches the edge of\n * the chart. If horizontal is true, the tooltip pointer will either be 'left' or 'right'. If horizontal is true, the\n * tooltip pointer will either be 'top' or 'bottom'.\n */\nexport const getCursorTooltipPoniterOrientation = ({ horizontal = true, theme }) => {\n    const pointerLength = theme && theme.tooltip ? Helpers.evaluateProp(theme.tooltip.pointerLength) : 10;\n    const orientationX = ({ center, flyoutWidth, width }) => width > center.x + flyoutWidth + pointerLength ? 'left' : 'right';\n    const orientationY = ({ center, flyoutHeight, height }) => height > center.y + flyoutHeight + pointerLength ? 'top' : 'bottom';\n    return horizontal ? orientationX : orientationY;\n};\n// Returns props associated with legend data\nexport const getLegendTooltipDataProps = (defaultProps) => (Object.assign({ borderPadding: 0, gutter: 0, orientation: 'vertical', padding: 0, rowGutter: 0, style: {\n        labels: {\n            fill: ChartLegendTooltipStyles.label.fill,\n            lineHeight: 0.275,\n            padding: 0\n        },\n        title: {\n            fill: ChartLegendTooltipStyles.label.fill,\n            padding: 0\n        }\n    } }, defaultProps));\n// Returns the legend height and width\nexport const getLegendTooltipSize = ({ legendData, legendOrientation = 'vertical', legendProps, text = '', theme }) => {\n    const textEvaluated = Helpers.evaluateProp(text);\n    const _text = Array.isArray(textEvaluated) ? textEvaluated : [textEvaluated];\n    // Find max char lengths\n    let maxDataLength = 0;\n    let maxTextLength = 0;\n    _text.map((name, index) => {\n        if (name) {\n            if (name.length > maxTextLength) {\n                maxTextLength = name.length;\n            }\n            const hasData = legendData && legendData[index] && legendData[index].name;\n            if (hasData) {\n                if (legendData[index].name.length > maxDataLength) {\n                    maxDataLength = legendData[index].name.length;\n                }\n            }\n        }\n    });\n    // Set length to ensure minimum spacing between label and value\n    let maxLength = maxDataLength + maxTextLength;\n    if (maxDataLength < 20) {\n        maxLength += 2;\n    }\n    // Get spacing to help align legend labels and text values\n    const spacer = 'x';\n    const getSpacing = (legendLabel, textLabel) => {\n        let spacing = '';\n        if (maxLength === 0) {\n            return spacing;\n        }\n        const legendLabelChars = legendLabel ? legendLabel.length : 0;\n        const textLabelChars = textLabel ? textLabel.length : 0;\n        const maxChars = legendLabelChars + textLabelChars;\n        // Add spacer\n        while (spacing.length < maxLength - maxChars) {\n            spacing += spacer;\n        }\n        return spacing;\n    };\n    // Format all text (similar to below) to help determine overall width.\n    //\n    // {name: \"Cats   no data\"}\n    // {name: \"Dogs         1\"}\n    // {name: \"Birds        4\"}\n    // {name: \"Mice         3\"}\n    const data = _text.map((label, index) => {\n        const hasData = legendData && legendData[index] && legendData[index].name;\n        const spacing = hasData ? getSpacing(legendData[index].name, label) : '';\n        return {\n            name: `${hasData ? legendData[index].name : ''}${spacing}${label}`\n        };\n    });\n    // Replace whitespace with spacer char for consistency in width\n    const formattedData = data.map(val => ({\n        name: val.name.replace(/ /g, spacer)\n    }));\n    // This should include both legend data and text\n    const widthDimensions = getLegendDimensions({\n        legendData: formattedData,\n        legendOrientation,\n        legendProps,\n        theme\n    });\n    // This should only use text. The row gutter changes when displaying all \"no data\" messages\n    const heightDimensions = getLegendDimensions({\n        legendData: _text.map((name) => ({ name })),\n        legendOrientation,\n        legendProps,\n        theme\n    });\n    return {\n        height: heightDimensions.height,\n        width: widthDimensions.width > 0 ? widthDimensions.width : 0\n    };\n};\n// Returns visible legend data, while syncing color scale. If textAsLegendData is true, the text prop is used as\n// legend data so y values can be passed individually to the label component\nexport const getLegendTooltipVisibleData = ({ activePoints, colorScale, legendData, text, textAsLegendData = false, theme }) => {\n    const textEvaluated = Helpers.evaluateProp(text);\n    const _text = Array.isArray(textEvaluated) ? textEvaluated : [textEvaluated];\n    const result = [];\n    // Sync data with interactive legends\n    if (legendData) {\n        let index = -1;\n        for (let i = 0; i < legendData.length; i++) {\n            const data = legendData[i];\n            const activePoint = activePoints ? activePoints.find(item => item.childName === data.childName) : '';\n            if (!activePoint ||\n                (data.symbol && data.symbol.type === 'eyeSlash' && data.symbol.fill === chart_color_black_500.value)) {\n                continue; // Skip hidden data\n            }\n            if (index++ < _text.length - 1) {\n                const themeColor = theme && theme.legend && theme.legend.colorScale\n                    ? theme.legend.colorScale[i % theme.legend.colorScale.length]\n                    : undefined;\n                result.push({\n                    name: textAsLegendData ? _text[index] : data.name,\n                    symbol: Object.assign({ fill: colorScale ? colorScale[i % colorScale.length] : themeColor }, data.symbol)\n                });\n            }\n        }\n    }\n    return result;\n};\n// Returns visible text for interactive legends\nexport const getLegendTooltipVisibleText = ({ activePoints, legendData, text }) => {\n    const textEvaluated = Helpers.evaluateProp(text);\n    const _text = Array.isArray(textEvaluated) ? textEvaluated : [textEvaluated];\n    const result = [];\n    if (legendData) {\n        let index = -1;\n        for (const data of legendData) {\n            const activePoint = activePoints ? activePoints.find(item => item.childName === data.childName) : '';\n            if (!activePoint ||\n                (data.symbol && data.symbol.type === 'eyeSlash' && data.symbol.fill === chart_color_black_500.value)) {\n                continue; // Skip hidden data\n            }\n            if (index++ < _text.length - 1) {\n                result.push(_text[index]);\n            }\n        }\n    }\n    return result;\n};\n//# sourceMappingURL=chart-tooltip.js.map"]},"metadata":{},"sourceType":"module"}